#!/usr/bin/python3
from collections import OrderedDict
from difflib import unified_diff
from io import StringIO
from subprocess import Popen, PIPE
from tempfile import NamedTemporaryFile
import cmd
import itertools
import logging
import os
import sys
import unittest


logger = logging.getLogger(__name__)

DEFAULT_TEST_LOG_LEVEL = 30  # Warning+error
DEFAULT_LOG_LEVEL = 20  # Warning+error+critical
HOME_NEEDLE = '__home__'
CONFIG_NEEDLE = 'conf-sync '


def _color(text, color):
    # find some lib for this?
    prefix = ''
    suffix = '\033[0m'
    if color == 'green':
        prefix = '\033[32m'
    elif color == 'yellow':
        prefix = '\033[33;4m'
    else:
        prefix = '\033[31m'

    return '{}{}{}'.format(prefix, text, suffix)


class SectionList(OrderedDict):

    def all_keys(self):
        return [x for x in super().keys()]

    def keys(self):
        '''Only the important ones.'''
        keys = [x for x in self.all_keys() if not x.startswith('unknown-')]
        return keys

def read_sections(configfile):
    sections = SectionList()

    unknown_count = 0
    current_section = None
    commenttag = '?'
   
    section_counts = {}
    def get_unique_section_name(section, sections=sections):
        '''TODO'''
        if section in section_counts:
            section_counts[section] += 1
            return '{}-{}'.format(section, section_counts[section])

        section_counts[section] = 1
        return section

    with open(configfile) as handle:
        for (lineno, line) in enumerate(line.rstrip('\n') for line in handle):

            if lineno == 0:
                if line[1:].strip() == 'conf-sync managed':
                    commenttag = line[0]

            if line.startswith(commenttag) and line[1:].strip().startswith(CONFIG_NEEDLE):
                options = [x.split('=', 1) for x in line[line.find(CONFIG_NEEDLE) + len(CONFIG_NEEDLE):].split(' ')]
                for option in options:
                    if option[0] == 'begin-section':
                        current_section = get_unique_section_name(option[1])
                    elif option[0] == 'end-section':
                        current_section = None
                    elif option[0] == 'managed':
                        if lineno != 0:
                            logger.warning('Ignoring managed option after the head.')
                        else:
                            current_section = 'header'
                    else:
                        raise Exception('Unknown config option {} while processing {}'.format(option, line))

            # Pre-write section test
            if current_section is None:
                # We don't know where we are!
                current_section = 'unknown-{}'.format(unknown_count)
                unknown_count += 1

            try:
                section = sections[current_section]
            except KeyError:
                section = sections[current_section] = []

            section.append(line)

            # You can only have 1 header-line
            if current_section == 'header':
                current_section = None

    return sections


class SourceConfig:
    '''

    Statuses:
    - new: destination file is missing
    - out-of-sync: source file has sections which the destination file doesn't have
    - can-be-updated: destination/source both have/don't have sections but differ in content
    - up-to-date: destination/source are the same
    '''

    def __init__(self, source=None, destination=None):
        self.source = source
        self.destination = destination
        self.status = 'unknown'
        self.source_sections = read_sections(self.source)
        try:
            self.destination_sections = read_sections(self.destination)
        except FileNotFoundError:
            logger.info('Could not read {}'.format(self.destination))
            self.destination_sections = None
        self._update_status()

    def __str__(self):
        return 'SourceConfig({} -> {})'.format(self.source, self.destination)

    def _update_status(self):
        if not os.path.exists(self.destination):
            self.status = 'new'
            return

        if not self.have_same_sections:
            self.status = 'out-of-sync'
            return

        logger.debug('Generating diff between %s and %s', self.source, self.destination)
        diff = self.diff()

        if next(diff, None) is not None:
            logger.info('Configuration {} can be updated.'.format(self.destination))
            self.status = 'can-be-updated'
            return

        logger.info('Configuration file {} is up-to-date'.format(self.destination))
        self.status = 'up-to-date'

    def update(self):
        new_config = self.generate_config()
        if os.path.exists(self.destination):
            with NamedTemporaryFile('w', prefix=self.destination.replace(os.sep, '_'), delete=False) as backup:
                with open(self.destination) as oldfile:
                    backup.write(oldfile.read())
                logger.warning('Made backup of {} as {}'.format(self.destination, backup.name))
        with open(self.destination, 'w') as handle:
            handle.write('\n'.join(new_config))

    def diff(self):
        source = self.generate_config()

        diff = unified_diff(
            self.destination_lines,
            source,
            'repo' + self.destination,
            'fs' + self.destination,
            lineterm='',
        )
        return diff

    def generate_config(self):
        prerequisite_for_merging = [
            self.source_sections.keys(),
            self.destination_sections.keys(),
            sorted(self.source_sections.keys()) == sorted(self.destination_sections.keys()),
        ]
        #import pdb; pdb.set_trace()
        if not all(prerequisite_for_merging):
            # We can't merge.
            return self.source_lines

        # Same sections in both files, hooray.
        # Strategy: Loop through the destination file in order, update parts that need updating. Profit.
        lines = []
        for section in self.destination_sections.all_keys():
            if section.startswith('unknown-'):
                lines += self.destination_sections[section]
            else:
                lines += self.source_sections[section]
        return lines

    @property
    def source_type(self):
        return self._type(self.source_sections)

    @property
    def destination_type(self):
        return self._type(self.destination_sections)

    @classmethod
    def _type(cls, sections):
        if self.keys():
            return 'sections'
        else:
            return 'whole'

    def needs_updating(self):
        return self.status in ('new', 'outdated', 'unmanaged')

    @property
    def source_lines(self):
        return list(itertools.chain(*self.source_sections.values()))
    
    @property
    def destination_lines(self):
        return list(itertools.chain(*self.destination_sections.values()))

    @property
    def nr_of_diff_sections(self):
        return self._nr_of_sections['diff']

    @property
    def nr_of_same_sections(self):
        return self._nr_of_sections['same']

    @property
    def _nr_of_sections(self):
        same_sections = 0
        all_keys = set(self.source_sections.keys()) | set(self.destination_sections.keys())
        for key in all_keys:
            try:
                if (self.source_sections[key] == self.destination_sections[key]):
                    same_sections += 1
            except KeyError:
                pass
        return {'same': same_sections, 'diff': len(all_keys) - same_sections}

    @property
    def have_same_sections(self):
        return (len(set(self.source_sections.keys()) ^ set(self.destination_sections.keys())) == 0)


def load_configurations(options):
    configurations = []
    filenames = os.listdir(options.source_dir)
    for filename in os.listdir(options.source_dir):
        if filename.startswith('.') and filename.endswith('.swp'):
            logger.debug('Skipping %s as its a temporary file made by editors.', filename)
            continue
        full_path = os.path.join(options.source_dir, filename)
        logger.debug('Found: {}'.format(filename))
        if os.path.isfile(full_path):
            source = full_path
            if filename.startswith(HOME_NEEDLE):
                destination = os.path.expanduser('~/' + filename[len(HOME_NEEDLE):])
            configurations.append(SourceConfig(source=source, destination=destination))
            
    logger.info('Found %s useable configuration files.', len(configurations))
    
    return configurations


def run_from_cli():
    
    ch = logging.StreamHandler()
    ch.setLevel(logging.DEBUG)
    formatter = logging.Formatter('%(asctime)s %(message)s', datefmt='%H:%M:%S')
    ch.setFormatter(formatter)
    logger.addHandler(ch)

    default_source_directory = os.path.join(os.path.dirname(__file__), 'configs')
    if not os.path.exists(default_source_directory):
        logger.warning("Directory %s does not exist, using example folder instead.", default_source_directory)
        default_source_directory = os.path.join(os.path.dirname(__file__), 'example-configs')

    import argparse
    parser = argparse.ArgumentParser(description='Manage dot files.')
    parser.add_argument('-s', '--source-dir', help='Directory with configuration files. Default: %(default)s', default=default_source_directory)
    parser.add_argument('-v', '--verbose', action='count', default=0)
    parser.add_argument('-q', '--quiet', action='count', default=0)
    parser.add_argument('-t', '--test-mode', action='store_true', help='Run all testcases.')
    parser.add_argument('--input-sequence', help=argparse.SUPPRESS)  # comma separated

    args = parser.parse_args()

    if args.test_mode:
        desired_loglevel = (DEFAULT_TEST_LOG_LEVEL - ((args.verbose - args.quiet) * 10))
        logger.setLevel(desired_loglevel)
        #unittest.main(argv=['', 'SourceConfigTest.test_order_preservation_with_update_with_sections'])
        unittest.main(argv=[''])

    desired_loglevel = (DEFAULT_LOG_LEVEL - ((args.verbose - args.quiet) * 10))
    logger.setLevel(desired_loglevel)

    #logger.debug('This is a debug message.')
    #logger.info('This is an info message.')
    #logger.warning('This is a warning message.')
    #logger.error('This is an error message.')
    #logger.critical('This is a critical message.')

    cui = Cui(options=args)

    if args.input_sequence:
        for command in args.input_sequence.split(','):
            print('{0}{1} [guided input]'.format(cui.prompt, command))
            cui.onecmd(command)
        print('<< end of guided input reached. >>')
    else:
        print('')
        cui.onecmd('list')
        cui.cmdloop()
        print('')

class CmdExitMixin:

    def can_exit(self):
        return True

    def onecmd(self, line):
        r = super().onecmd(line)
        if r and (self.can_exit() or
           raw_input('exit anyway ? (yes/no):')=='yes'):
             return True
        return False

    def do_exit(self, s):
        return True

    def help_exit(self):
        print('Exit the interpreter.')
        print('You can also use the Ctrl-D shortcut.')

    do_EOF = do_exit
    help_EOF= help_exit

    do_q = do_exit
    help_q = help_exit

    do_quit = do_exit
    help_quit = help_exit

def config_choice(f):
    def call_f_with_config(self, s):
        try:
            one_based_choice = int(s)
            conf = self.configurations[one_based_choice - 1]
        except ValueError:
            print("That's not a valid number.")
            return
        except IndexError:
            print("That's not a valid choice.")
            return

        f(self, conf)

    return call_f_with_config

class Cui(CmdExitMixin, cmd.Cmd):

    def __init__(self, *args, options=None, **kwargs):
        self.options = options
        self.prompt = '\n(config) '
        print('')
        super().__init__(*args, **kwargs)

    def do_list(self, s):
        #print('-' * 78)
        self._do_reread()
        print('')

        print('{:>3} {:^8} {:^17} {:>5} {:^5} {:30}'.format('ID', 'Type', 'Status', '#same', '#diff', 'Configuration file'))
        print('{:-^3} {:-^8} {:-^17} {:->5} {:->5} {:-^30}'.format(*([''] * 99)))
        for (one_based_index, conf) in enumerate(self.configurations, start=1):
            print('{:>3} {:^8} {:^17} {:>5} {:>5} {}'.format(
                one_based_index, 
                conf.destination_type,
                conf.status, 
                conf.nr_of_same_sections,
                conf.nr_of_diff_sections,
                conf.destination
            ))

    def emptyline(self):
        pass

    @config_choice
    def do_show(self, conf):
        print('''
Current state: {0.status}
Source:        {0.source}
Destination:   {0.destination}'''.format(
            conf,
        ))
        source_keys = list(conf.source_sections.keys())
        destination_keys = list(conf.destination_sections.keys())
        if source_keys == destination_keys:
            print('Section:       ', end='')
            for key in source_keys:
                if conf.source_sections[key] == conf.destination_sections[key]:
                    print(_color(key, 'green'), end=' ')
                else:
                    print(_color(key, 'yellow'), end=' ')
            print('')
        else:
            print('diff sections. {} != {}'.format(source_keys, destination_keys))

    @config_choice
    def do_diff(self, conf):
        diff = conf.diff()
        pager = Popen([os.environ.get('PAGER', '/usr/bin/less')], stdin=PIPE)
        pager.communicate(input='\n'.join(diff).encode('UTF-8'))

    @config_choice
    def do_update(self, conf):
        conf.update()
        print('Updated {}'.format(conf.destination))

    #def do_reread(self, s):
    #    print('')
    #    self._do_reread()
    #    print('')
    #    self.do_list(s)

    def _do_reread(self):
        self.configurations = load_configurations(self.options)


class SourceConfigTest(unittest.TestCase):

    def make_config(self, content):
        # NB: Testcases probably won't work on something like Windows where you cannot open the same file multiple times for writing.
        tempfile = NamedTemporaryFile()
        tempfile.write(content.lstrip('\n').rstrip(' ').encode('UTF-8'))
        tempfile.flush()
        return tempfile

    @classmethod
    def get_testcase_path(cls, filename):
        return os.path.join(os.path.dirname(__file__), 'testcases', filename)

    def test_empty_diff(self):
        tempfile = self.make_config('''
" This is a sample configuration file
value1 = 'some string'
value2 = 3
        ''')
        conf = SourceConfig(source=tempfile.name, destination=tempfile.name)
        self.assertEqual(list(conf.diff()), [])

    def test_order_preservation_with_update_with_sections(self):
        source = self.get_testcase_path('testcase_order_preserving_in_sections_source.conf')
        destination = self.get_testcase_path('testcase_order_preserving_in_sections_destination.conf')
        conf = SourceConfig(source=source, destination=destination)
        self.assertEqual(conf.source_sections.keys(), ['header', 'specific-order', 'some-non-specific-order', 'specific-order-2', 'another-non-specific-order'])
        self.assertEqual(conf.destination_sections.keys(), ['header', 'specific-order', 'another-non-specific-order', 'specific-order-2', 'some-non-specific-order'])
        actual_outcome = conf.generate_config()
        with open(self.get_testcase_path('testcase_order_preserving_in_sections_outcome.conf')) as handle:
            expected_outcome = [x.rstrip('\n') for x in handle.readlines()]
        self.assertEqual(expected_outcome, actual_outcome)


    def test_update_with_sections(self):
        inputfile = self.make_config('''
# conf-sync managed
# conf-sync begin-section=should-stay-in-sync
important_setting = "improved string"
# conf-sync end-section
unimportant_value = 42
        ''')
        outputfile = self.make_config('''
# conf-sync managed
# conf-sync begin-section=should-stay-in-sync
important_setting = "outdated string"
# conf-sync end-section
unimportant_value = 1337
''')
        conf = SourceConfig(source=inputfile.name, destination=outputfile.name)
        self.assertEqual(conf.source_sections.keys(), ['header', 'should-stay-in-sync'])
        self.assertEqual(conf.source_sections.all_keys(), ['header', 'should-stay-in-sync', 'unknown-0'])
        self.assertEqual(conf.destination_sections.keys(), ['header', 'should-stay-in-sync'])
        self.assertEqual(conf.destination_sections.all_keys(), ['header', 'should-stay-in-sync', 'unknown-0'])

        diff = list(conf.diff())
        self.assertEqual(diff[0][:9], '--- repo/')
        self.assertEqual(diff[1][:7], '+++ fs/')
        self.assertEqual(diff[2:], [
            '@@ -1,5 +1,5 @@', 
            ' # conf-sync managed',
            ' # conf-sync begin-section=should-stay-in-sync',
            '-important_setting = "outdated string"',
            '+important_setting = "improved string"',
            ' # conf-sync end-section',
            ' unimportant_value = 1337',
        ])


    def test_update_without_sections(self):
        inputfile = self.make_config('''
# This is a sample configuration file
value1 = "improved string"
value2 = 3
        ''')
        outputfile = self.make_config('''
# This is a sample configuration file
value1 = "outdated string"
value2 = 3
''')
        conf = SourceConfig(source=inputfile.name, destination=outputfile.name)
        diff = list(conf.diff())
        self.assertEqual(diff[0][:9], '--- repo/')
        self.assertEqual(diff[1][:7], '+++ fs/')
        self.assertEqual(diff[2:], [
            '@@ -1,3 +1,3 @@', 
            ' # This is a sample configuration file',
            '-value1 = "outdated string"',
            '+value1 = "improved string"',
            ' value2 = 3'
        ])


    def test_parsing_conf_without_sections_hash(self):
        tempfile = self.make_config('''
# This is a sample configuration file
value1 = "some string"
value2 = 3
        ''')
        conf = SourceConfig(source=tempfile.name, destination=tempfile.name)
        self.assertEqual(conf.status, 'up-to-date')
        self.assertEqual(conf.source_sections.all_keys(), ['unknown-0'])
        self.assertEqual(conf.source_sections.keys(), [])


    def test_parsing_conf_without_sections_semicolon(self):
        tempfile = self.make_config('''
; This is a sample configuration file
value1 = "some string"
value2 = 3
        ''')
        tempfile.flush()
        conf = SourceConfig(source=tempfile.name, destination=tempfile.name)
        self.assertEqual(conf.status, 'up-to-date')
        self.assertEqual(conf.source_sections.keys(), [])
        self.assertEqual(conf.source_sections.all_keys(), ['unknown-0'])


    def test_parsing_conf_without_sections_doublequote(self):
        tempfile = self.make_config('''
" This is a sample configuration file
value1 = 'some string'
value2 = 3
        ''')
        conf = SourceConfig(source=tempfile.name, destination=tempfile.name)
        self.assertEqual(conf.status, 'up-to-date')
        self.assertEqual(conf.source_sections.keys(), [])
        self.assertEqual(conf.source_sections.all_keys(), ['unknown-0'])

    def test_parsing_conf_with_sections_hash(self):
        tempfile = self.make_config('''
# conf-sync managed
id = 2014-07-14v0
"foo" = "bar"
'bar' = 'qux'
# conf-sync begin-section=dessert
ingredients = ['ice', 'fruit', 'syrup']
        ''')
        conf = SourceConfig(source=tempfile.name, destination=tempfile.name)
        self.assertEqual(conf.status, 'up-to-date')
        self.assertEqual(conf.source_sections.keys(), ['header', 'dessert'])
        self.assertEqual(conf.source_sections.all_keys(), ['header', 'unknown-0', 'dessert'])
        self.assertEqual(conf.source_sections['header'], ['# conf-sync managed'])
        self.assertEqual(conf.source_sections['unknown-0'], [
            'id = 2014-07-14v0',
            '"foo" = "bar"',
            "'bar' = 'qux'",
        ])
        self.assertEqual(conf.source_sections['dessert'], [
            '# conf-sync begin-section=dessert',
            "ingredients = ['ice', 'fruit', 'syrup']",
        ])


    def test_parsing_conf_with_sections_semicolon(self):
        tempfile = self.make_config('''
; conf-sync managed
id = 2014-07-14v0

; The line below should not actually start a section since the line doesn't start with a semicolon
# conf-sync begin-section=pizza
"foo" = "bar"
'bar' = 'qux'

; conf-sync begin-section=dessert
ingredients = ['ice', 'fruit', 'syrup']
        ''')
        conf = SourceConfig(source=tempfile.name, destination=tempfile.name)
        self.assertEqual(conf.status, 'up-to-date')
        self.assertEqual(conf.source_sections.keys(), ['header', 'dessert'])
        self.assertEqual(conf.source_sections.all_keys(), ['header', 'unknown-0', 'dessert'])
        self.assertEqual(conf.source_sections['header'], ['; conf-sync managed'])
        self.assertEqual(conf.source_sections['unknown-0'], [
            'id = 2014-07-14v0',
            '',
            "; The line below should not actually start a section since the line doesn't start with a semicolon",
            '# conf-sync begin-section=pizza',
            '"foo" = "bar"',
            "'bar' = 'qux'",
            '',
        ])
        self.assertEqual(conf.source_sections['dessert'], [
            '; conf-sync begin-section=dessert',
            "ingredients = ['ice', 'fruit', 'syrup']",
        ])




    def test_parsing_conf_with_multipe_headers(self):
        tempfile = self.make_config('''
# conf-sync managed

id = 2014-07-14v0
# conf-sync managed

num = 234
        ''')
        conf = SourceConfig(source=tempfile.name, destination=tempfile.name)
        self.assertEqual(conf.status, 'up-to-date')
        self.assertEqual(conf.source_sections.keys(), ['header'])
        self.assertEqual(conf.source_sections.all_keys(), ['header', 'unknown-0'])
        self.assertEqual(conf.source_sections['header'], ['# conf-sync managed'])
        self.assertEqual(conf.source_sections['unknown-0'], [
            '', 
            'id = 2014-07-14v0', 
            '# conf-sync managed', 
            '',
            'num = 234'
        ])


    def test_parsing_conf_with_implicit_close_hash(self):
        tempfile = self.make_config('''
# conf-sync managed
id = 2014-07-14v0

# conf-sync begin-section=personal
name = John Doe
age = 39
# conf-sync end-section

# This comment is in no mans land because we closed the personal section

# conf-sync begin-section=business
# This comment is in business land
company = ACME

# conf-sync begin-section=misc
# This comment is in misc land (note that we didn't explicitly close the previous section, that's allowed.
status = on-holiday
        ''')
        conf = SourceConfig(source=tempfile.name, destination=tempfile.name)
        self.assertEqual(conf.status, 'up-to-date')
        self.assertEqual(conf.source_sections.keys(), ['header', 'personal', 'business', 'misc'])
        self.assertEqual(conf.source_sections.all_keys(), ['header', 'unknown-0', 'personal', 'unknown-1', 'business', 'misc'])
        self.assertEqual(conf.source_sections['business'], [
            '# conf-sync begin-section=business', 
            '# This comment is in business land', 
            'company = ACME', 
            ''
        ])
        self.assertEqual(conf.source_sections['misc'], [
            '# conf-sync begin-section=misc', 
            "# This comment is in misc land (note that we didn't explicitly close the previous section, that's allowed.", 
            'status = on-holiday'
        ])


if __name__ == '__main__':

    run_from_cli()
