#!/usr/bin/python3
from collections import OrderedDict
from difflib import unified_diff
from io import StringIO
from subprocess import Popen, PIPE
from tempfile import NamedTemporaryFile
import cmd
import itertools
import logging
import os
import sys
import unittest


logger = logging.getLogger(__name__)

DEFAULT_TEST_LOG_LEVEL = 30  # Warning+error
DEFAULT_LOG_LEVEL = 20  # Warning+error+critical
HOME_NEEDLE = '__home__'
CONFIG_NEEDLE = 'conf-sync '


def _color(text, color):
    # find some lib for this?
    prefix = ''
    suffix = '\033[0m'
    if color == 'green':
        prefix = '\033[32m'
    elif color == 'yellow':
        prefix = '\033[33;4m'
    else:
        prefix = '\033[31m'

    return '{}{}{}'.format(prefix, text, suffix)


class SectionList(OrderedDict):
    @property
    def has_sections(self):
        '''Whether this file has any sections'''
        return (list(self.keys()) != ['unknown-0'])

def read_sections(configfile):
    sections = SectionList()

    unknown_count = 0
    current_section = 'unknown-0'
    commenttag = '?'
   
    with open(configfile) as handle:
        for (lineno, line) in enumerate(line.rstrip('\n') for line in handle):

            if lineno == 0:
                if line[1:].strip() == 'conf-sync managed':
                    commenttag = line[0]

            if current_section == 'header':
                # Headers only span 1 line
                current_section = 'unknown-{}'.format(unknown_count)

            if line.startswith(commenttag) and line[1:].strip().startswith(CONFIG_NEEDLE):
                options = [x.split('=', 1) for x in line[line.find(CONFIG_NEEDLE) + len(CONFIG_NEEDLE):].split(' ')]
                for option in options:
                    if option[0] == 'begin-section':
                        current_section = option[1]
                    elif option[0] == 'end-section':
                        unknown_count += 1
                        current_section = 'unknown-{}'.format(unknown_count)
                    elif option[0] == 'managed':
                        if lineno != 0:
                            logger.warning('Ignoring managed option after the head.')
                        else:
                            current_section = 'header'
                    else:
                        raise Exception('Unknown config option {} while processing {}'.format(option, line))

            # Storing line
            if current_section not in sections:
                sections[current_section] = []
            section = sections.get(current_section, [])
            section.append(line)

    return sections


class SourceConfig:
    '''

    Statuses:
    - unknown: call update_conf_status to determine update
    - missing: destination file is missing
    - unmanaged: destination file doesn't have sections, while the source file has
    - outdated: destination/source both have/don't have sections but differ in content
    - up-to-date: destination/source are the same
    '''

    def __init__(self, source=None, destination=None):
        self.source = source
        self.destination = destination
        self.status = 'unknown'
        self.source_sections = read_sections(self.source)
        try:
            self.destination_sections = read_sections(self.destination)
        except FileNotFoundError:
            logger.info('Could not read {}'.format(self.destination))
        self._update_status()

    def __str__(self):
        return 'SourceConfig({} -> {})'.format(self.source, self.destination)

    def _update_status(self):
        if not os.path.exists(self.destination):
            self.status = 'Missing'
            return

        if not self.have_same_sections:
            self.status = 'unmanaged'
            return

        logger.debug('Generating diff between %s and %s', self.source, self.destination)
        diff = generate_diff(self)

        if next(diff, None) is not None:
            logger.info('Configuration {} can be updated.'.format(self.destination))
            self.status = 'outdated'
            return

        logger.info('Configuration file {} is up-to-date'.format(self.destination))
        self.status = 'up-to-date'


    @property
    def needs_updating(self):
        return self.status in ('missing', 'outdated', 'unmanaged')

    @property
    def source_lines(self):
        return list(itertools.chain(*self.source_sections.values()))
    
    @property
    def destination_lines(self):
        return list(itertools.chain(*self.destination_sections.values()))

    @property
    def nr_of_diff_sections(self):
        return self._nr_of_sections['diff']

    @property
    def nr_of_same_sections(self):
        return self._nr_of_sections['same']

    @property
    def _nr_of_sections(self):
        same_sections = 0
        all_keys = set(self.source_sections.keys()) | set(self.destination_sections.keys())
        for key in all_keys:
            try:
                if (self.source_sections[key] == self.destination_sections[key]):
                    same_sections += 1
            except KeyError:
                pass
        return {'same': same_sections, 'diff': len(all_keys) - same_sections}

    @property
    def have_same_sections(self):
        return (len(set(self.source_sections.keys()) ^ set(self.destination_sections.keys())) == 0)


def update_all_configuration_statuses(configurations):
    for conf in configurations:
        update_conf_status(conf)


def generate_diff(conf):
    diff = unified_diff(
        conf.destination_lines,
        conf.source_lines,
        'repo' + conf.destination,
        'fs' + conf.destination,
        lineterm='',
    )
    return diff


def load_configurations(options):
    configurations = []
    for filename in os.listdir(options.source_dir):
        if filename.startswith('.') and filename.endswith('.swp'):
            logger.debug('Skipping %s as its a temporary file made by editors.', filename)
            continue
        full_path = os.path.join(options.source_dir, filename)
        logger.debug('Found: {}'.format(filename))
        if os.path.isfile(full_path):
            source = full_path
            if filename.startswith(HOME_NEEDLE):
                destination = os.path.expanduser('~/' + filename[len(HOME_NEEDLE):])
            configurations.append(SourceConfig(source=source, destination=destination))
            
    logger.info('Found %s useable configuration files.', len(configurations))
    
    return configurations


def run_from_cli():
    
    ch = logging.StreamHandler()
    ch.setLevel(logging.DEBUG)
    formatter = logging.Formatter('%(asctime)s %(message)s', datefmt='%H:%M:%S')
    ch.setFormatter(formatter)
    logger.addHandler(ch)

    default_source_directory = os.path.join(os.path.dirname(__file__), 'configs')

    import argparse
    parser = argparse.ArgumentParser(description='Manage dot files.')
    parser.add_argument('-s', '--source-dir', help='Directory with configuration files. Default: %(default)s', default=default_source_directory)
    parser.add_argument('-v', '--verbose', action='count', default=0)
    parser.add_argument('-q', '--quiet', action='count', default=0)
    parser.add_argument('-t', '--test-mode', action='store_true', help='Run all testcases.')
    parser.add_argument('--input-sequence', help=argparse.SUPPRESS)  # comma separated

    args = parser.parse_args()

    if args.test_mode:
        desired_loglevel = (DEFAULT_TEST_LOG_LEVEL - ((args.verbose - args.quiet) * 10))
        logger.setLevel(desired_loglevel)
        unittest.main(argv=[''])

    desired_loglevel = (DEFAULT_LOG_LEVEL - ((args.verbose - args.quiet) * 10))
    logger.setLevel(desired_loglevel)

    #logger.debug('This is a debug message.')
    #logger.info('This is an info message.')
    #logger.warning('This is a warning message.')
    #logger.error('This is an error message.')
    #logger.critical('This is a critical message.')

    cui = Cui(options=args)

    if args.input_sequence:
        for command in args.input_sequence.split(','):
            print('{0}{1} [guided input]'.format(cui.prompt, command))
            cui.onecmd(command)
        print('<< end of guided input reached. >>')
    else:
        print('')
        cui.onecmd('list')
        cui.cmdloop()
        print('')

class CmdExitMixin:

    def can_exit(self):
        return True

    def onecmd(self, line):
        r = super().onecmd(line)
        if r and (self.can_exit() or
           raw_input('exit anyway ? (yes/no):')=='yes'):
             return True
        return False

    def do_exit(self, s):
        return True

    def help_exit(self):
        print('Exit the interpreter.')
        print('You can also use the Ctrl-D shortcut.')

    do_EOF = do_exit
    help_EOF= help_exit


def config_choice(f):
    def call_f_with_config(self, s):
        try:
            one_based_choice = int(s)
            conf = self.configurations[one_based_choice - 1]
        except ValueError:
            print("That's not a valid number.")
            return
        except IndexError:
            print("That's not a valid choice.")
            return

        f(self, conf)

    return call_f_with_config

class Cui(CmdExitMixin, cmd.Cmd):

    def __init__(self, *args, options=None, **kwargs):
        self.options = options
        self.prompt = '\n(config) '
        print('')
        self._do_reread()
        super().__init__(*args, **kwargs)

    def do_list(self, s):
        print('')
        print('{:>3} {:>10} {:>5} {:^5} {}'.format('ID', 'Status', '#same', '#diff', 'Configuration file'))
        print('{:-^3} {:->10} {:->5} {:->5} {:-^5}'.format(*([''] * 99)))
        for (one_based_index, conf) in enumerate(self.configurations, start=1):
            print('{:>3} {:^10} {:>5} {:>5} {}'.format(
                one_based_index, 
                conf.status, 
                conf.nr_of_same_sections,
                conf.nr_of_diff_sections,
                conf.destination
            ))

    def emptyline(self):
        pass

    @config_choice
    def do_show(self, conf):
        print('''
Current state: {0.status}
Source:        {0.source}
Destination:   {0.destination}'''.format(
            conf,
        ))
        source_keys = list(conf.source_sections.keys())
        destination_keys = list(conf.destination_sections.keys())
        if source_keys == destination_keys:
            print('Section:       ', end='')
            for key in source_keys:
                if conf.source_sections[key] == conf.destination_sections[key]:
                    print(_color(key, 'green'), end=' ')
                else:
                    print(_color(key, 'yellow'), end=' ')
            print('')
        else:
            print('diff sections. {} != {}'.format(source_keys, destination_keys))

    @config_choice
    def do_diff(self, conf):
        diff = generate_diff(conf)
        pager = Popen([os.environ.get('PAGER', '/usr/bin/less')], stdin=PIPE)
        pager.communicate(input='\n'.join(diff).encode('UTF-8'))

    @config_choice
    def do_update(self, conf):
        if os.path.exists(conf.destination):
            with NamedTemporaryFile('w', prefix=conf.destination.replace(os.sep, '_'), delete=False) as backup:
                with open(conf.destination) as oldfile:
                    backup.write(oldfile.read())
                logger.warning('Made backup of {} as {}'.format(conf.destination, backup.name))
        with open(conf.destination, 'w') as handle:
            handle.write('\n'.join(conf.source_lines))
        print('Updated {}'.format(conf.destination))

    def do_reread(self, s):
        print('')
        self._do_reread()
        print('')
        self.do_list(s)

    def _do_reread(self):
        self.configurations = load_configurations(self.options)
        update_all_configuration_statuses(self.configurations)


class SourceConfigTest(unittest.TestCase):
    # NB: Testcases probably only work on POSIX-like systems

    def make_config(self, content):
        tempfile = NamedTemporaryFile()
        tempfile.write(content.lstrip('\n').rstrip(' ').encode('UTF-8'))
        tempfile.flush()
        return tempfile

    def test_parsing_conf_without_sections_hash(self):
        tempfile = self.make_config('''
# This is a sample configuration file
value1 = "some string"
value2 = 3
        ''')
        conf = SourceConfig(source=tempfile.name, destination=tempfile.name)
        self.assertEqual(conf.status, 'up-to-date')
        self.assertEqual(conf.source_sections.has_sections, False)
        self.assertEqual(list(conf.source_sections.keys()), ['unknown-0'])

    def test_parsing_conf_without_sections_semicolon(self):
        tempfile = self.make_config('''
; This is a sample configuration file
value1 = "some string"
value2 = 3
        ''')
        tempfile.flush()
        conf = SourceConfig(source=tempfile.name, destination=tempfile.name)
        self.assertEqual(conf.status, 'up-to-date')
        self.assertEqual(conf.source_sections.has_sections, False)
        self.assertEqual(list(conf.source_sections.keys()), ['unknown-0'])

    def test_parsing_conf_without_sections_doublequote(self):
        tempfile = self.make_config('''
" This is a sample configuration file
value1 = 'some string'
value2 = 3
        ''')
        tempfile.flush()
        conf = SourceConfig(source=tempfile.name, destination=tempfile.name)
        self.assertEqual(conf.status, 'up-to-date')
        self.assertEqual(conf.source_sections.has_sections, False)
        self.assertEqual(list(conf.source_sections.keys()), ['unknown-0'])

    def test_parsing_conf_with_sections_hash(self):
        tempfile = self.make_config('''
# conf-sync managed
id = 2014-07-14v0
        ''')
        conf = SourceConfig(source=tempfile.name, destination=tempfile.name)
        self.assertEqual(conf.status, 'up-to-date')
        self.assertEqual(conf.source_sections.has_sections, True)
        self.assertEqual(list(conf.source_sections.keys()), ['header', 'unknown-0'])

    def test_parsing_conf_with_multipe_headers(self):
        tempfile = self.make_config('''
# conf-sync managed

id = 2014-07-14v0
# conf-sync managed

num = 234
        ''')
        conf = SourceConfig(source=tempfile.name, destination=tempfile.name)
        self.assertEqual(conf.status, 'up-to-date')
        self.assertEqual(conf.source_sections.has_sections, True)
        self.assertEqual(list(conf.source_sections.keys()), ['header', 'unknown-0'])



    def test_parsing_conf_with_implicit_close_hash(self):
        tempfile = self.make_config('''
# conf-sync managed
id = 2014-07-14v0

# conf-sync begin-section=personal
name = John Doe
age = 39
# conf-sync end-section

# This comment is in nomans land because we closed the personal section

# conf-sync begin-section=business
# This comment is in business land
company = ACME

# conf-sync begin-section=misc
# This comment is in misc land (note that we didn't explicitly close the previous section, that's allowed.
status = on-holiday
        ''')
        conf = SourceConfig(source=tempfile.name, destination=tempfile.name)
        self.assertEqual(conf.status, 'up-to-date')
        self.assertEqual(conf.source_sections.has_sections, True)
        self.assertEqual(list(conf.source_sections.keys()), ['header', 'unknown-0', 'personal', 'unknown-1', 'business', 'misc'])

if __name__ == '__main__':

    run_from_cli()
